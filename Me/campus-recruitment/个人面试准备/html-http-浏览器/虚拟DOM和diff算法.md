# React 虚拟 Dom 和 diff 算法

  ## 虚拟 Dom

  > React将DOM抽象为虚拟DOM, 然后通过新旧虚拟DOM 这两个对象的差异(Diff算法),最终只把变化的部分重新渲染,提高渲染效率的过程;

  虚拟DOM是在DOM的基础上在内存建立了一个抽象层，对数据和状态所做的任何改动，都会被自动且高效的同步到虚拟DOM，最后再批量同步到DOM中

  render执行的结果得到的并不是真正的DOM节点，而仅仅是javascript对象，称之为虚拟DOM

  虚拟DOM具有批处理和高效的Diff算法，可以无需担心性能问题而随时‘刷新’整个页面，因为虚拟DOM能保证对界面上真正变化的部分进行实际的DOM操作

  【传统DOM操作(eg:innerHtml)】：render html+重建所有DOM元素
  【虚拟DOM】：render 虚拟DOM + diff算法+更新必要的DOM元素

  ## diff 算法
  1. 
    - 当你实际开发使用React的时候，在某个时间点 render() 函数创建了一棵React元素树,也就模拟一个虚拟 DOM 树，
    - 在下一个state或者props更新的时候，render() 函数将创建一棵新的React元素树, 也就模拟了一个新的虚拟 DOM 树，
    - 既然模拟出了新旧两棵DOM 树, 那么如何高效的进行新旧两棵树的对比呢??
    - 当然是使用 DIff 算法...
  2. 传统的 Diff 算法也是一直都有的
    - 但是它的时间复杂度为O(n^3) 意思是: 在React中更新10个元素则需要进行1000次的比较。(1000个===10亿)
  3. React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n^1=n) 复杂度的问题
    - 两个不同类型的元素会产生不同的树 
    - 对于同一层级的一组子节点，它们可以通过唯一 key 进行区分
    - 基于以上两个前提策略，React 分别对 tree diff、component diff 以及 element diff 三种 diff 方法是 进行算法优化


### Tree Diff
  > 概念: 将新旧两颗虚拟 DOM 树,按照层级对应的关系,从头到尾的遍历一遍,,就能找到那些元素是需要更新的,这种方式: Tree Diff

### Component Diff
  不同组件之间的对比
  > 概念: 在对比每一个层级的时候,会有自己的组件,这种组件的对比方式就叫: Component Diff ;
​           这种对比方法其实比较的就是类型.↓↓↓
  - 如果类型相同,暂时不更新,

  - 如果类型不相同,就需要更新;   (  删除旧的组件,再创建一个新的组件,插入到删除组件的那个位置)

### Element Diff

  同一层级中元素之间的对比
  > 概念: 在类型相同的组件内, 再继续对比组件内部的元素,查看内部元素是否相同,如果需要修改,找到需要修改的元素,进行针对性的修改! 这种方式就叫: Element Diff

### diff 算法总结:


  - 保持完整的结构,有利于性能的提升

  - 尽量使用相同类型的组件

  - 在进行 Element 或Component 级别对比的时候,为了提高对比的效率, React 推荐我们为每个 for 循环创建出来的元素或者组件,提供一个唯一的 key;

  - Tree diff :将新旧两棵 DOM 树,按照层级对应的关系,这样只需要对树进行一次遍历,就能够找到哪些元素是需要更新的;

  - Component Diff: 在对比每一层的时候,每一层都有自己的组件, 那么组件之间的对比,叫做 Component diff , 对比的方式,就是查看两个组件的类型是否相同,如果相同,则暂时认为不需要更新,如果类型不同,则表示更新(先把旧的组件删除,再创建一个新的组件,插入到刚才删除的位置);

  - Element Diff:如果新旧 DOM 树中的组件类型相同,会继续比较这两个组件内部的元素是否也相同,如果元素发生了改变,则找到需要修改的元素,有针对性的修改,这种组件内部元素级别的对比叫: Element Diff;  


[参考一](https://juejin.im/post/5a3200fe51882554bd5111a0)
[参考二](https://www.jianshu.com/p/55e67e8739f6)